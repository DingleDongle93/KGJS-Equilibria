/// <reference path='../../kg.ts' />

import * as d3 from "d3";
import { UnivariateFunctionDefinition, UnivariateFunction } from "../../math/univariateFunction";
import { ViewObjectDefinition, ViewObject } from "./viewObject";
import { setDefaults, setProperties } from "../../util";



export interface AreaDefinition extends ViewObjectDefinition {
    univariateFunction1: UnivariateFunctionDefinition;
    univariateFunction2?: UnivariateFunctionDefinition;
    above?: boolean;
    autoGeneratedBaseline?: boolean;
}

export class Area extends ViewObject {

    private interpolation;

    private areaShape;
    private areaPath;

    private univariateFunction1: UnivariateFunction;
    private univariateFunction2: UnivariateFunction;

    constructor(def: AreaDefinition) {

        const minValue = def.univariateFunction1?.ind == 'x' ? (def.yScale ? def.yScale.domainMin : 0) : (def.xScale ? def.xScale.domainMin : 0);
        const maxValue = def.univariateFunction1?.ind == 'x' ? (def.yScale ? def.yScale.domainMax : 1) : (def.xScale ? def.xScale.domainMax : 1);

        def.autoGeneratedBaseline = !def.hasOwnProperty('univariateFunction2');

        const univariateFunction2Def: any = {
            "fn": ((def.above && !def.useTopScale) || (!def.above && def.useTopScale)) ? maxValue : minValue
        };
        if (def.univariateFunction1) {
            if (def.univariateFunction1['ind'] !== undefined) univariateFunction2Def['ind'] = def.univariateFunction1['ind'];
            if (def.univariateFunction1['min'] !== undefined) univariateFunction2Def['min'] = def.univariateFunction1['min'];
            if (def.univariateFunction1['max'] !== undefined) univariateFunction2Def['max'] = def.univariateFunction1['max'];
            if (def.univariateFunction1['samplePoints'] !== undefined) univariateFunction2Def['samplePoints'] = def.univariateFunction1['samplePoints'];
        }

        setDefaults(def, {
            interpolation: 'curveBasis',
            ind: 'x',
            fill: 'lightsteelblue',
            opacity: 0.2,
            univariateFunction2: univariateFunction2Def
        });

        setProperties(def, 'constants', ['interpolation']);

        def.univariateFunction1.model = def.model;
        def.univariateFunction2.model = def.model;

        // need to initialize the functions before the area, so they exist when it's time to draw the area
        const univariateFunction1 = new UnivariateFunction(def.univariateFunction1),
            univariateFunction2 = new UnivariateFunction(def.univariateFunction2);

        super(def);

        this.univariateFunction1 = univariateFunction1;
        this.univariateFunction2 = univariateFunction2;
    }

    // create SVG elements
    draw(layer) {
        let ab = this;

        ab.rootElement = layer.selectAll('path.rootElement-' + ab.id).data([1]).join('path').attr('class', 'rootElement-' + ab.id);

        ab.areaShape = d3.area()
            .x0(function (d: any) {
                return ab.xScale.scale(d[0].x);
            })
            .y0(function (d: any) {
                return ab.yScale.scale(d[0].y);
            })
            .x1(function (d: any) {
                return ab.xScale.scale(d[1].x);
            })
            .y1(function (d: any) {
                return ab.yScale.scale(d[1].y);
            });

        ab.areaPath = ab.rootElement;

        return ab.addClipPathAndArrows();
    }

    // update properties
    redraw() {
        const area = this;

        if (area.univariateFunction1 != undefined && area.univariateFunction2 != undefined) {

            const fn1 = area.univariateFunction1,
                fn2 = area.univariateFunction2,
                scale = fn1.ind == 'y' ? area.yScale : area.xScale;

            fn1.generateData(scale.domainMin, scale.domainMax);
            fn2.generateData(scale.domainMin, scale.domainMax);

            area.areaPath
                .data([d3.zip(fn1.data, fn2.data)])
                .attr('d', area.areaShape);

            area.drawFill(area.areaPath);
        } else {
            //console.log('area functions undefined')
        }

        return area;
    }

    // update self and functions
    update(force) {
        let area = super.update(force);

        if ((area.def as AreaDefinition).autoGeneratedBaseline && area.xScale != undefined && area.yScale != undefined && area.univariateFunction1 != undefined && area.univariateFunction2 != undefined) {
            const def = area.def as AreaDefinition;
            const minValue = area.univariateFunction1.ind == 'x' ? area.yScale.domainMin : area.xScale.domainMin;
            const maxValue = area.univariateFunction1.ind == 'x' ? area.yScale.domainMax : area.xScale.domainMax;
            const targetVal = ((def.above && !def.useTopScale) || (!def.above && def.useTopScale)) ? maxValue : minValue;
            if (targetVal != undefined && area.univariateFunction2.fnStringDef !== targetVal.toString()) {
                area.univariateFunction2.fnStringDef = targetVal.toString();
                area.univariateFunction2.hasChanged = true;
                area.univariateFunction2.update(true);
            }
        }

        if (!area.hasChanged) {
            if (area.univariateFunction1 && area.univariateFunction2 && (area.univariateFunction1.hasChanged || area.univariateFunction2.hasChanged)) {
                area.redraw();
            }
        }
        return area;
    }



}
